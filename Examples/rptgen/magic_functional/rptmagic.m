function rptmagic(ranks, type, showReport, showStatus)
%RPTMAGIC Generate a magic-squares report
% RPTMAGIC() generates an HTML report on magic squares of size
% 10, 20, 40, 75.
%
% RPTMAGIC(RANKS) generates an HTML report on magic squares specified
% by an array of magic square sizes.
%
% RPTMAGIC(RANKS, TYPE, DISPLAY) displays the report if DISPLAY is
% true.
%
% RPTMAGIC(RANKS, TYPE, DISPLAY, STATUS) displays status messages
% generated by report if STATUS is true.
%
%   
%  This function reproduces the MATLAB Report Generator's magic-square.rpt
%  report example. It produces a report on a user-specifiable set of
%  magic squares, i.e., square arrays whose rows and columns and
%  diagonals add up to the same value. This report consists of an
%  introduction to magic squares and a chapter for each square
%  specifiedby the user. Each chapter displays a
%  magic square as a table or a color-coded image, depending on the
%  size of the square.
%
%  This function relies on a template to generate a report. The
%  template contains the following sections
%
%      * Title page with a hole for today's date
%      * A table of contents page that automatically generates a
%        TOC for the report
%      * An introduction to magic squares followed by a hole for
%        magic square chapters
%
%  This function loops through the holes in the template filling in the
%  date and magic square chapters to generate the report. 

%   Copyright MathWorks, 2013-2014.

switch nargin
    case 0
        ranks = [10, 20, 40, 75];
        type = 'html';
        showReport = false;
        showStatus = false;
    case 1
        type = 'html';
        showReport = false;
        showStatus = false;
    case 2
        type = lower(type);
        showReport = false;
        showStatus = false;
    case 3
        showStatus = false;
end

% This statement eliminates the need to qualify the names of DOM
% objects in this function, e.g., you can refer to 
% mlreportgen.dom.Document simply as Document.
import mlreportgen.dom.*;

% The following lines register a listener for DOM API status
if showStatus
    dispatcher = mlreportgen.dom.MessageDispatcher.getTheDispatcher;
    addlistener(dispatcher, ...
        'Message', ...
        @(src,data) disp(evtdata.Message.formatAsText));
end

% Get location of magic square master template.
%
% Note that there are two versions of the template, an HTML version and
% a Word version. If we do not specify the template extensions, the DOM
% API will pick the correct version, depending on the output document
% type.

templatePath = sprintf('magic_squares_%s', type);

reportPath = 'magic';

% Construct a document to generate the report.
rpt = Document(reportPath, type, templatePath);

% Initialize variable used to store paths of images used to render
% the magic squares if they are too big to fit on a page as a table.
% Closing the report copies these images into the report output package
% at which point the originals can be deleted.
imagePaths = {};

% Loop through the holes in the report template, filling each.
% Note that using a switch statement embedded in a while loop
% makes this code impervious to changes in the number, order, and
% type of holes in the template. For example, using this construct
% would allow you to rearrange holes in the template or have different
% sets of holes for Word and HTML.
%
% Note also that you can achieve the same end with less code by
% subclassing Document class with methods for filling the holes and
% relying on Document class's fill method to invoke the hole-filling
% methods in the correct order.
while ~strcmp(rpt.CurrentHoleId, '#end#')
    switch rpt.CurrentHoleId
        case 'ReportDate'
            append(rpt, date);
        case 'SquareChapters'
            for i = 1:length(ranks)
                [chapter, imagePath] = genChapter(rpt, ranks(i));
                append(rpt, chapter);
                if ~isempty(imagePath)
                    imagePaths = [imagePaths, {imagePath}]; %#ok<AGROW>
                end
            end
    end
    moveToNextHole(rpt);
end

% This operation copies any magic square images generated by this report
% into the report output package. The originals can then be deleted.
close(rpt);

% Delete the originals of any magic square iamges.
nImages = numel(imagePaths);
for i = 1:nImages
    delete(imagePaths{i});
end

if showReport
    rptview(rpt);
end

end


function [chapter, imagePath]  = genChapter(rpt, rank)
% This function create a magic squares chapter by filling holes
% in a template that specifies the fixed content and layout
% of the chapter. Specifically the chapter template contains
% an automatically numbered chapter heading prefix (Chapter N.)
% with a hole for filling in the chapter title. Following the
% heading is a hole for a depiction of a magic square as
% a table or a color-coded image, depending on the square's
% size.
import mlreportgen.dom.*;

% This variable is used to return the path of the image used to render
% the magic square, if the magic square is too big to fit on a page as
% a table. This allows the main function to delete the image after
% closing the report, which copies the image into the report output 
% package so that it is no longer needed.
imagePath = '';

% Create a document part based on the chapter template. A
% document part is basically a subdocument that can be appended to
% a document or another document part. It allows you to modularize
% your report generation application. The following method creates the
% document part from a template named 'Chapter' residing in the report's
% document part template library.
chapter = DocumentPart(rpt, 'Chapter');

% Loop through the holes in the template.
while ~strcmp(chapter.CurrentHoleId, '#end#')
    switch chapter.CurrentHoleId
        case 'ChapterTitle'
            append(chapter, sprintf('Rank %d Magic Square', rank));
        case 'MagicSquare'
            % Compute the magic square of the specified rank, using
            % MATLAB's magic function.
            square = magic(rank);
            
            % If the square's rank is less than 25, assume that it
            % will fit onto a page as a table; otherwise, render it
            % as an image.
            if rank < 25
                % Append the magic square as a table to the
                % chapter. Note that the Table constructor accepts
                % an MxN numeric array as an argument and converts
                % it to a table. It also accepts the name of a
                % table style defined in the template.
                table = Table(square, 'MagicSquare');
                % set row and column separators
                table.Style = { ...
                    RowSep('solid', 'black', '1px'), ...
                    ColSep('solid', 'black', '1px'), };
                % set the border
                table.Border = 'double';
                % set entries aligment
                table.TableEntriesStyle = { HAlign('right') };
                append(chapter, table);
            else
                % Clear any prexisting figures.
                clf;
                
                % Display square as a color-coded figure.
                imagesc(square);
                title(sprintf('Magic Square N=%i', rank))
                set(gca,'Ydir','normal');
                axis equal;
                axis tight;
                
                % Convert the figure to a png image for inclusion
                % in the chapter.
                imagePath = sprintf('magic%d.png', rank);
                print(gcf, '-dpng', imagePath);
                image = Image(imagePath);
                
                % Scale the image to an approximate square.
                image.Height = '4 in';
                image.Width = '6 in';
                append(chapter, image);
                delete(gcf);
            end
    end
    chapter.moveToNextHole;
end

close(chapter);

end




